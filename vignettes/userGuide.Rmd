%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{R/qtlcharts User Guide}

# R/qtlcharts User Guide

[R/qtlcharts](http://kbroman.github.io/qtlcharts) is an
[R](http://www.r-project.org) package to create interactive charts for
QTL data, for use with [R/qtl](http://www.rqtl.org).

The charts are saved to a temporary file and opened in a web browser,
though you may also save them to a specific file, to be viewed later.
We are focusing development on the
[Chrome](http://www.google.com/chrome/browser) and
[Safari](https://www.apple.com/safari/) browsers. The graphs may also
be viewed in other browsers, such [Opera](http://www.opera.com/) and
[Firefox](http://www.mozilla.org/en-US/firefox/new/), but it can be
hard to accommodate all possible browser differences.

Information on installing R/qtlcharts is available
[here](http://kbroman.github.io/qtlcharts/pages/installation.html); it
requires installation of the packages [R/qtl](http://www.rqtl.org),
[jsonlite](http://cran.r-project.org/web/packages/jsonlite/), and
[devtools](https://github.com/hadley/devtools).

## Basic use

You first need to load the package.

```{r load_library}
library(qtlcharts)
```

Let's begin by considering the function `iplotCorr`, which creates
a heatmap of a correlation matrix, linked to scatterplots of the
underlying variables.

We'll first load the `geneExpr` dataset, example data included with
the R/qtlcharts package.

```{r geneExpr_data}
data(geneExpr)
```

This is a list with two components. The first, `geneExpr$expr`, which is a
`r nrow(geneExpr$expr)` &times; `r ncol(geneExpr$expr)` matrix of gene
expression data, and `geneExpr$genotype`, which is a vector of
genotypes (of length `r length(geneExpr$genotype)`) at a QTL that
influences those `r ncol(geneExpr$expr)` genes' expression
values. (The genes were selected from a larger expression QTL study,
on that basis: that they are all influenced by this QTL.)

Let's pull out those two components of `geneExpr` as separate objects,
`expr` and `geno`.

```{r split_geneExpr}
expr <- geneExpr$expr
geno <- geneExpr$genotype
```

The simplest use of `iplotCorr` is with a numeric matrix, as with
these data. For example:

```{r iplotCorr_reordered, eval=FALSE}
iplotCorr(expr, reorder=TRUE)
```

This will open an interactive figure in a web browser, with a heat map
of the correlation matrix of the genes on the left linked to
the underlying scatterplots. The argument `reorder=TRUE`, the genes
are reordered (by hierarchical clustering with the R function
`hclust`) to bring genes with similar expression patterns next to each
other.

The following is a snapshot.

![iplotCorr example](Figs/iplotCorr1.png)

The left panel is a heat map of the correlation matrix. If you hover
over a pixel the panel, the individual correlations are shown. If you
click on a pixel, the corresponding scatterplot is shown on the right.

We can have the scatterplot colored by the QTL genotype contained in
the vector `geno`, throught the `group` argument.

```{r iplotCorr_reordered_with_genotype, eval=FALSE}
iplotCorr(expr, geno, reorder=TRUE)
```

Here's a snapshot of the result.

![iplotCorr example with scatterplot colored by genotype](Figs/iplotCorr2.png)


Each chart function in R/qtlcharts has `title` and `caption` arguments
to add a title and caption to the chart. By default, the title is
empty, while the caption contains a standard description of the
chart's use.

If you want to add a title but remove the caption, you might do the following:

```{r iplotCorr_title_caption, eval=FALSE}
iplotCorr(expr, title="Correlation matrix linked to scatterplots",
          caption="")
```

## Saving to a file

The interactive graphs produced by R/qtlcharts are, by default, saved
to a temporary file and then opened in the default web browser. If you
want to save a chart to a _particular_ file, use the `file`
argument, as follows:

```{r iplotCorr_specify_file, eval=FALSE}
iplotCorr(expr, reorder=TRUE, file="~/Desktop/iplotCorr_example.html")
```

The chart will still be opened in the browser. To create the file
without opening it, use the argument `openfile=FALSE`, as follows:

```{r iplotCorr_specify_file_dont_open, eval=FALSE}
iplotCorr(expr, reorder=TRUE, file="~/Desktop/iplotCorr_example.html",
          openfile=FALSE)
```

Charts saved in this way will contain links to resources within the
R/qtlcharts package, and so will not be portable to another system
that doesn't have R/qtlcharts installed, or that has the package
installed in a different location.

To make the interactive graph portable to other computers (for
example, for sharing with collaborators), use the argument
`onefile=TRUE`, as follows:

```{r iplotCorr_make_portable, eval=FALSE}
iplotCorr(expr, reorder=TRUE, file="~/Desktop/iplotCorr_example.html",
          onefile=TRUE)
```

The file will be somewhat larger, but it will be self-contained and so
may be transferred to and viewed on any computer.


## Chart customization options

There are a number of ways in which one may wish to customize the
interactive graphs produced by
[R/qtlcharts](http://kbroman.github.io/qtlcharts), such as different
colors or axis labels. Our main approach to allow such customization
is through a function argument, `chartOpts`. It takes a named list.

For example, to change the dimensions of the image produced by
`iplotCorr`, use the `height` option, which specifies the height of
each panel in pixels; by default, the images are square, with `width =
height`:


```{r iplotCorr_height, eval=FALSE}
iplotCorr(expr, reorder=TRUE, chartOpts=list(height=600))
```

If you want the points in the scatterplot to be different color, use
`scatcolors`.

```{r iplotCorr_scatcolors, eval=FALSE}
iplotCorr(expr, reorder=TRUE,
          chartOpts=list(scatcolors="lightblue"))
```

Of course, you can modify both `height` and `scatcolors` at once.

```{r iplotCorr_height_and_scatcolors, eval=FALSE}
iplotCorr(expr, reorder=TRUE,
          chartOpts=list(height=600, scatcolors="lightblue"))
```

If the points are to be colored by genotype, you need to specify the
same number of colors as there are genotype groups.

```{r iplotCorr_multiscatcolors, eval=FALSE}
iplotCorr(expr, geno, reorder=TRUE,
          chartOpts=list(scatcolors=c("lightblue", "lightgreen", "pink")))
```

A full list of options is available in the
[`chartOpts` vignette](http://kbroman.githu.b.io/qtlcharts/vignettes/chartOpts.html):

```{r chartOpts_vignette, eval=FALSE}
vignette("chartOpts", "qtlcharts")
```


## Including a chart in an R Markdown document

The interactive charts may be included within an
[R Markdown](https://www.rstudio.com/ide/docs/r_markdown)-based
report. See the separate [`Rmarkdown` vignette](http://kbroman.github.io/qtlcharts/assets/vignettes/Rmarkdown.html):

```{r Rmarkdown_vignette, eval=FALSE}
vignette("Rmarkdown", "qtlcharts")
```




## Examples of the use of the charts

### `iplotCorr`

`iplotCorr` creates an heat map of a correlation matrix, linked to the
underlying scatterplots. We've shown a few examples above, but there
are several other features to consider.

By default, `iplotCorr` will calculate the correlation matrix to be
displayed, using Pearson's correlation; this can be sensitive to
outliers. If you wish to use a different statistic, provide the matrix
with the argument `corr`. For example, to use Spearman's rank correlation:

```{r iplotCorr_spearman, eval=FALSE}
data(geneExpr)
expr <- geneExpr$expr
geno <- geneExpr$genotype
spearman <- cor(expr, use="pairwise.complete.obs", method="spearman")

iplotCorr(expr, geno, corr=spearman)
```

If you provide your own correlation measure, the `reorder` argument is
ignored. If you want to reorder the genes, to bring correlated genes
together, you need to do it yourself. You can use `hclust` for this.

```{r iplotCorr_own_reorder, eval=FALSE}
ord <- hclust(as.dist(-spearman))$order
iplotCorr(expr[,ord], geno, corr=spearman[ord,ord])
```

You can view just a portion of the correlation matrix by specifying
`rows` and `cols`. For example, we could fit a regression line for
each gene, relating the expression pattern to the eQTL genotype, in
order to identify the genes with positive and negative associations
with genotype.

```{r get_eqtl_effect_est}
beta <- apply(expr, 2, function(y,x) lm(y~x)$coef[2], geno)
pos <- which(beta > 0)
neg <- which(beta < 0)
```

We could then look at just the portion of the correlation matrix where
the rows are genes with positive effects and the columns are genes
with negative effects.

```{r iplotCorr_subset_of_corr, eval=FALSE}
iplotCorr(expr, geno, rows=pos, cols=neg)
```

If you wish to use a different correlation statistic, you need to do
the subsetting in advance, as the `rows` and `cols` arguments are
ignored if `corr` is provided.

```{r iplotCorr_subset_of_spearman_corr, eval=FALSE}
iplotCorr(expr, geno, corr=spearman[pos,neg])
```



### `iplotMap`

`iplotMap` creates a (slightly) interactive genetic map. Hover over a
marker position to view the marker name.

Let's first load the `hyper` data included with
[R/qtl](http://www.rqtl.org) and pull out the genetic map with
`pull.map`.


```{r, load_hyper}
data(hyper)
map <- pull.map(hyper)
```

We use `iplotMap` as follows.

```{r iplotMap_example, eval=FALSE}
iplotMap(map)
```

If you want to shift each chromosome so that the initial marker is at
0, use `shift=TRUE`.

```{r iplotMap_shift, eval=FALSE}
iplotMap(map, shift=TRUE)
```

`iplotMap` will also take a cross object, in which case it uses
`pull.map` to extract and then plot the map.

```{r iplotMap_w_cross, eval=FALSE}
iplotMap(hyper)
```

If you want to change the x- and y-axis labels, you need to use the
`chartOpts` argument:

```{r iplotMap_xylab, eval=FALSE}
iplotMap(map, chartOpts=list(xlab="Linkage group", ylab="Position (Mbp)"))
```

If you want to plot a subset of the chromosomes, you need to select
them yourself:

```{r iplotMap_selected_chr, eval=FALSE}
iplotMap(map[c(5, 10, 15, "X")])
```

The `title` argument gives an overall title for the chart.

```{r iplotMap_title, eval=FALSE}
iplotMap(map, title="Selected chromosomes")
```

The `title` argument via `chartOpts` puts a title centered above the
map panel.

```{r iplotMap_chartOpts_title, eval=FALSE}
iplotMap(map, chartOpts=list(title="Selected chromosomes"))
```


### `iplotScanone`

`iplotScanone` creates an interactive chart with LOD
curves from a genome scan linked to estimated QTL effects.

Let's first load the `hyper` data, included with [R/qtl](http://www.rqtl.org)

```{r, load_hyper_and_scan}
data(hyper)
hyper <- calc.genoprob(hyper, step=1)
out <- scanone(hyper)
```

If you provide just the output from `scanone`, the only interactivity
is that hovering over marker positions on the LOD curves will give
information about the marker name, position, and LOD score.

```{r iplotScanone_example, eval=FALSE}
iplotScanone(out)
```

You can use the `chr` to plot only selected chromosomes.

```{r iplotScanone_selected_chr, eval=FALSE}
iplotScanone(out, chr=c(1, 4, 6, 15))
```

If you also provide the cross object, clicking on the markers will
generate a QTL effect plot on the right. By default, means with &plusmn; 1
SE error bars will be shown.

```{r iplotScanone_w_eff, eval=FALSE}
iplotScanone(out, hyper)
```

By default, in calculating the means and standard errors, a single
imputation is used to handle missing genotype information, using the
[R/qtl](http://www.rqtl.org) function `fill.geno`. Arguments may be
passed to `fill.geno` as a list, with the argument `fillgenoArgs`. For
example, to do the imputation by Viterbi, assuming a 1% genotyping
error rate, do the following:

```{r iplotScanone_fillgenoArgs, eval=FALSE}
iplotScanone(out, hyper, fillgenoArgs=list(method="argmax", error.prob=0.01))
```

If you want to plot raw phenotypes vs genotypes, rather than mean
&plusmn; SE, use `pxgtype="raw"`, as follows:

```{r iplotScanone_rawpxg, eval=FALSE}
iplotScanone(out, hyper, pxgtype="raw")
```

In the phenotype &times; genotype plot, pink points indicate that the
genotype was imputed.

To change the color of the LOD curves, use the `chartOpts` option
`lod_linecolor`. Colors are named as in html, or with hex RGB codes
like `"#842DCE"` or `#82C`. (See examples
[here](http://www.computerhope.com/htmcolor.htm) and a list of named
colors [here](http://html-color-codes.info/color-names/).)

```{r iplotScanone_lodlinecolor, eval=FALSE}
iplotScanone(out, hyper, chartOpts=list(lod_linecolor="black"))
```

You can change the background colors with the `chartOpts` options
`darkrect` and `lightrect`.

```{r iplotScanone_rectcolor, eval=FALSE}
iplotScanone(out, hyper, chartOpts=list(darkrect="#CCC", lightrect="#EEE"))
```

Change the colors of the lines in the mean &plusmn; SE plot with the
`chartOpts` option `eff_linecolor`.

```{r iplotScanone_efflinecolor, eval=FALSE}
iplotScanone(out, hyper, chartOpts=list(lod_linecolor="DarkViolet",
                                        eff_linecolor="DarkViolet"))
```






### `iplotMScanone`

`iplotMScanone` creates a heatmap of LOD curves for a set of genome
scans (for each, for each of a time course of phenotypes), linked to a
plot of the individual genome scans, and also to the QTL effects.

```{r iplotMScanone_example, eval=FALSE}
data(grav)
grav <- calc.genoprob(grav, step=1)
grav <- reduce2grid(grav)
phecol <- seq(1, nphe(grav), by=5)
out <- scanone(grav, phe=phecol)
eff <- estQTLeffects(grav, phe=phecol, what="effects")

iplotMScanone(out, effects=eff,
              title="iplotMScanone example",
              chartOpts=list(eff_ylab="QTL effect"))
```


### `iplotCurves`

`iplotCurves` creates a plot of a set of curves linked to one or two
scatterplots.

As an example, we'll consider the phenotypes in the dataset `grav`,
included with R/qtlcharts.

```{r iplotCurves_data}
data(grav)
times <- attr(grav, "time")
phe <- grav$pheno
```

The object `phe` is an `r nrow(phe)`&times;`r ncol(phe)` matrix:
curves for `r nrow(phe)` individuals at `r ncol(phe)` time points,
with the time points specified by `times`.

The simplest use of `iplotCurves` is the following.

```{r iplotCurves_simple, eval=FALSE}
iplotCurves(phe)
```

This plots the rows of `phe` as a set of curves. If you hover over a
curve, it will be highlighted, and the individual ID (taken from the
rownames) will be displayed on the right. If the input matrix has no
row names, numeric indices are used.

The values on the x-axis are simply column indices. To use the
actual values in `times`, include it as a second argument.

```{r iplotCurves_wtimes, eval=FALSE}
iplotCurves(phe, times)
```

To change the axis labels, pass `curves_xlab` and `curves_ylab` using
`chartOpts`.

```{r iplotCurves_axislab, eval=FALSE}
iplotCurves(phe, times, chartOpts=list(curves_xlab="Time (hrs)",
                                       curves_ylab="Response"))
```

The `curves_` bit is to distinguish this panel from the
optional scatterplot panels; more on this below. You can use just
`xlab` and `ylab`, as follows.

```{r iplotCurves_axislabalt, eval=FALSE}
iplotCurves(phe, times, chartOpts=list(xlab="Time (hrs)",
                                       ylab="Response"))
```

More interesting is to have the curves linked to scatterplots, of
the response at particular times. For example, 2 hrs vs 4 hrs and 4
hrs vs 6 hrs. This is done by providing two-column matrices whose rows
correspond to the main matrix.

```{r iplotCurves_bigex, eval=FALSE}
iplotCurves(phe, times, phe[,times==2 | times==4], phe[,times==4 | times==6],
            chartOpts=list(curves_xlab="Time (hours)", curves_ylab="Response",
                           scat1_xlab="Angle at 2 hrs", scat1_ylab="Angle at 4 hrs",
                           scat2_xlab="Angle at 4 hrs", scat2_ylab="Angle at 6 hrs"))
```

You can also have just one linked scatterplot.

```{r iplotCurves_onescat, eval=FALSE}
iplotCurves(phe, times, phe[,times==2 | times==4],
            chartOpts=list(curves_xlab="Time (hours)", curves_ylab="Response",
                           scat1_xlab="Angle at 2 hrs", scat1_ylab="Angle at 4 hrs"))
```

You can also include a numeric vector of groups assignments for the
curves, to have groups of curves and points with common colors. For
example, we can pull out the genotype for a marker and color the
curves by their genotype. We'll use the `fill.geno` function in
[R/qtl](http://www.rqtl.org) to impute any missing genotypes.

```{r iplotCurves_groups, eval=FALSE}
g <- pull.geno(fill.geno(grav))[,"BF.206L-Col"]
iplotCurves(phe, times, phe[,times==2 | times==4], phe[,times==4 | times==6],
            group=g,
            chartOpts=list(curves_xlab="Time (hours)", curves_ylab="Response",
                           scat1_xlab="Angle at 2 hrs", scat1_ylab="Angle at 4 hrs",
                           scat2_xlab="Angle at 4 hrs", scat2_ylab="Angle at 6 hrs"))
```

To change the colors that are used in the plot, you need to provide a
vector of colors with the `chartOpts` options `strokecolor`, `strokecolorhilit`,
`pointcolor`, and `pointcolorhilit`. If you want the points and curves
to be the same, you can just use `color` and `colorhilit`.

```{r iplotCurves_colors, eval=FALSE}
iplotCurves(phe, times, phe[,times==2 | times==4], phe[,times==4 | times==6],
            group=g,
            chartOpts=list(curves_xlab="Time (hours)", curves_ylab="Response",
                           scat1_xlab="Angle at 2 hrs", scat1_ylab="Angle at 4 hrs",
                           scat2_xlab="Angle at 4 hrs", scat2_ylab="Angle at 6 hrs",
                           color=c("pink", "lightblue"), colorhilit=c("red", "blue")))
```


### `iboxplot`

`iboxplot` creates an interactive graph for a large set of box plots
(rendered as lines connecting the quantiles), linked to underlying
histograms.

Let's first simulate some data. These data are not particularly
interesting: 10,000 measurements from 500 normal distributions with a
common SD but shifts in the mean.

```{r iboxplot_simdata}
# simulated data
n.ind <- 500
n.gene <- 10000
mat <- matrix(rnorm(n.ind * n.gene, rnorm(n.ind, 5)), ncol=n.gene)
dimnames(mat) <- list(paste0("ind", 1:n.ind),
                      paste0("gene", 1:n.gene))
```

`iboxplot` expects a matrix, with the rows corresponding to
individuals and the columns corresponding to measurements; the plotted
boxplots will characterize the distributions in each row.

```{r iboxplot_example, eval=FALSE}
iboxplot(mat)
```

In the upper panel, each curve represents a particular quantile
and connects the values for the different individuals, who are
arranged along the x-axis. (By default, the individuals are sorted by
their median; use `orderByMedian=FALSE` to prevent this reordering.)
Hover over a different individuals and the corresponding histograms
are shown below. Click to have a particular histogram retained; click
again (if you can do so precisely!) to remove.

If you want to order the individuals in a different way, you need to
rearrange the rows of the matrix in advance and then use
`orderByMedian=FALSE`. For example, to order the individuals by their
99.9th percentiles, you could do:

```{r iboxplot_orderBy99, eval=FALSE}
iboxplot(mat[order(apply(mat, 1, quantile, 0.99)),], orderByMedian=FALSE)
```

By default, the function plots the 0.1, 1, 10, 25, and 50, 75, 90, 99,
and 99.9th percentiles. To plot a different set of percentiles, use
the argument `qu`, giving a vector of numeric values between 0 and
0.5. The median will always be included, and for every quantile $q$,
the corresponding $1-q$ quantile will be included as well.

To leave off the 0.1 and 99.9 percentiles, do the following.

```{r iboxplot_diff_quant, eval=FALSE}
iboxplot(mat, qu=c(0.25, 0.05, 0.01))
```

To use different colors for the quantile curves, include the option
`qucolors` through the `chartOpts` argument. The vector should have
length `length(qu)+1` (so, by default, 5). For each quantile $q$, the
same color is used for the corresponding quantile $1-q$. Here's an
example. The first color will correspond to the median, and then they
move from the inside out.

```{r iboxplot_qucolors, eval=FALSE}
iboxplot(mat, qu=c(0.25, 0.05, 0.01),
         chartOpts=list(qucolors=c("black", "green", "red", "blue")))
```

You can change the bins in the histograms in the lower panel through
the argument `breaks`. If a single numeric value, it indicates the
number of bins; if a vector, it indicates the endpoints for the bins.
The vector of breakpoints do not need to span the range of the data,
but a warning will be issued if they don't.

Here's an example specifying the number of bins.

```{r iboxplot_breaks, eval=FALSE}
iboxplot(mat, breaks=151)
```

Here's an example specifying actual bins. (This will issue a warning.)

```{r iboxplot_breaks2, eval=FALSE}
iboxplot(mat, breaks=seq(2, 8, by=0.1))
```

To change the axis labels, use the `chartOpts` options `xlab` and
`ylab`, for the x- and y-axes, respectively, in the top panel. The
y-axis label in the top panel will be used as the x-axis label in the
lower panel.

```{r iboxplot_axislab, eval=FALSE}
iboxplot(mat, chartOpts=list(xlab="Mice", ylab="Expression level"))
```

### `iheatmap`

`iheatmap` creates an interactive heatmap of a numeric matrix, with
pixels linked to plots of horizontal and vertical slices.

We'll first generate a set of data to plot:
$z(x,y) = x y \exp(-x^2 - y^2)$,
for $x,y \in [-2, 2]$

```{r iheatmap_data}
n <- 101
x <- y <- seq(-2, 2, len=n)
z <- matrix(ncol=n, nrow=n)
for(i in seq(along=x))
  for(j in seq(along=y))
    z[i,j] <- x[i]*y[j]*exp(-x[i]^2 - y[j]^2)
```

We can now call `iheatmap` with these data. The first argument is a
matrix with the $z$-values. The next two optional arguments are
vectors that indicate the $x$ and $y$ values.

```{r iheatmap_example, eval=FALSE}
iheatmap(z, x, y)
```

By default, the `iheatmap` takes as the range for the z-axis,
$[-M, M]$ where $M = \max |z|$. If you want a different range, you can use the
option `zlim` with `chartOpts`; you need to provide three values: the
minimum, the center, and the maximum. The color of the heatmap
can be controlled with the option `colors`; again this is a vector of
three values: the color for the minimum, the color for the middle
value, and the color for the maximum value.

Here's an example with expanded z-axis limits and different colors.

```{r iheatmap_diffcolors, eval=FALSE}
iheatmap(z, x, y,
         chartOpts=list(zlim=c(-1, 0, 1),
                        colors=c("purple", "white", "orangered")))
```

The labels for the axes can be controlled with the options `xlab`,
`ylab`, and `zlab`. Here's an example.

```{r iheatmap_axislab, eval=FALSE}
iheatmap(z, x, y, chartOpts=list(xlab="theta", ylab="psi", zlab="response"))
```



<!-- the following to make it look nicer -->
<link href="http://kbroman.github.io/qtlcharts/assets/vignettes/vignette.css" rel="stylesheet"></link>
